-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/dustin/mqttd#readme</a>
@package mqttd
@version 0.1.0.0

module MQTTD.Config
data Config
Config :: Bool -> Map ByteString User -> [Listener] -> ListenerOptions -> PersistenceConfig -> Config
[_confDebug] :: Config -> Bool
[_confUsers] :: Config -> Map ByteString User
[_confListeners] :: Config -> [Listener]
[_confDefaults] :: Config -> ListenerOptions
[_confPersist] :: Config -> PersistenceConfig
data User
User :: ByteString -> ByteString -> [ACL] -> User
data ACL
Allow :: Filter -> ACL
Deny :: Filter -> ACL
newtype PersistenceConfig
PersistenceConfig :: FilePath -> PersistenceConfig
[_persistenceDBPath] :: PersistenceConfig -> FilePath
data Listener
MQTTListener :: HostPreference -> PortNumber -> ListenerOptions -> Listener
MQTTSListener :: HostPreference -> PortNumber -> FilePath -> FilePath -> ListenerOptions -> Listener
WSListener :: ListenAddress -> PortNumber -> ListenerOptions -> Listener
data ListenerOptions
ListenerOptions :: Maybe Bool -> ListenerOptions
[_optAllowAnonymous] :: ListenerOptions -> Maybe Bool
listenerOpts :: Lens' Listener ListenerOptions
parseConfFile :: String -> IO Config
instance GHC.Show.Show MQTTD.Config.Section
instance GHC.Classes.Eq MQTTD.Config.Config
instance GHC.Show.Show MQTTD.Config.Config
instance GHC.Classes.Eq MQTTD.Config.PersistenceConfig
instance GHC.Show.Show MQTTD.Config.PersistenceConfig
instance GHC.Classes.Eq MQTTD.Config.Listener
instance GHC.Show.Show MQTTD.Config.Listener
instance GHC.Show.Show MQTTD.Config.ListenerOptions
instance GHC.Classes.Eq MQTTD.Config.ListenerOptions
instance GHC.Classes.Eq MQTTD.Config.User
instance GHC.Show.Show MQTTD.Config.User
instance GHC.Classes.Eq MQTTD.Config.ACL
instance GHC.Show.Show MQTTD.Config.ACL
instance GHC.Base.Semigroup MQTTD.Config.ListenerOptions
instance GHC.Base.Monoid MQTTD.Config.ListenerOptions

module MQTTD.SubTree

-- | MQTT Topic Subscription tree.
data SubTree a

-- | An empty SubTree.
--   
--   This exists in addition to <a>mempty</a> so one can create a SubTree
--   for a values that are not monoidal.
empty :: SubTree a

-- | Modify a subscription for the given filter.
--   
--   This will create structure along the path and will not clean up any
--   unused structure.
modify :: Filter -> (Maybe a -> Maybe a) -> SubTree a -> SubTree a

-- | Add a value at the given filter path.
add :: Monoid a => Filter -> a -> SubTree a -> SubTree a

-- | Find subscribers of a given topic.
find :: Monoid a => Topic -> SubTree a -> a

-- | Find all matching subscribers
findMap :: Monoid m => Topic -> (a -> m) -> SubTree a -> m

-- | flatten a SubTree to a list of (topic,a) pairs.
flatten :: SubTree a -> [(Filter, a)]

-- | Construct a SubTree from a list of filters and subscribers (assuming
--   monoidal values).
fromList :: Monoid a => [(Filter, a)] -> SubTree a
instance Data.Traversable.Traversable MQTTD.SubTree.SubTree
instance GHC.Base.Functor MQTTD.SubTree.SubTree
instance GHC.Classes.Eq a => GHC.Classes.Eq (MQTTD.SubTree.SubTree a)
instance GHC.Show.Show a => GHC.Show.Show (MQTTD.SubTree.SubTree a)
instance Data.Foldable.Foldable MQTTD.SubTree.SubTree
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (MQTTD.SubTree.SubTree a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (MQTTD.SubTree.SubTree a)

module MQTTD.Types
data MQTTException
MQTTPingTimeout :: MQTTException
MQTTDuplicate :: MQTTException
type PktQueue = TBQueue MQTTPkt
type ClientID = Int
type SessionID = ByteString
type BLTopic = ByteString
type BLFilter = ByteString
data ConnectedClient
ConnectedClient :: ConnectRequest -> ThreadId -> ClientID -> TVar (Map Word16 ByteString) -> TVar (Map ByteString Word16) -> TVar Word16 -> ConnectedClient
[_clientConnReq] :: ConnectedClient -> ConnectRequest
[_clientThread] :: ConnectedClient -> ThreadId
[_clientID] :: ConnectedClient -> ClientID
[_clientAliasIn] :: ConnectedClient -> TVar (Map Word16 ByteString)
[_clientAliasOut] :: ConnectedClient -> TVar (Map ByteString Word16)
[_clientALeft] :: ConnectedClient -> TVar Word16
clientThread :: Lens' ConnectedClient ThreadId
clientID :: Lens' ConnectedClient ClientID
clientConnReq :: Lens' ConnectedClient ConnectRequest
clientAliasOut :: Lens' ConnectedClient (TVar (Map ByteString Word16))
clientAliasIn :: Lens' ConnectedClient (TVar (Map Word16 ByteString))
clientALeft :: Lens' ConnectedClient (TVar Word16)
data Session
Session :: SessionID -> [ACL] -> Maybe ConnectedClient -> PktQueue -> TVar (Map PktID PublishRequest) -> TVar (Map Filter SubOptions) -> Maybe UTCTime -> Maybe LastWill -> Session
[_sessionID] :: Session -> SessionID
[_sessionACL] :: Session -> [ACL]
[_sessionClient] :: Session -> Maybe ConnectedClient
[_sessionChan] :: Session -> PktQueue
[_sessionQP] :: Session -> TVar (Map PktID PublishRequest)
[_sessionSubs] :: Session -> TVar (Map Filter SubOptions)
[_sessionExpires] :: Session -> Maybe UTCTime
[_sessionWill] :: Session -> Maybe LastWill
sessionWill :: Lens' Session (Maybe LastWill)
sessionSubs :: Lens' Session (TVar (Map Filter SubOptions))
sessionQP :: Lens' Session (TVar (Map PktID PublishRequest))
sessionID :: Lens' Session SessionID
sessionExpires :: Lens' Session (Maybe UTCTime)
sessionClient :: Lens' Session (Maybe ConnectedClient)
sessionChan :: Lens' Session PktQueue
sessionACL :: Lens' Session [ACL]
defaultSessionExp :: NominalDiffTime
data Authorizer
Authorizer :: Map ByteString User -> Bool -> Authorizer
[_authUsers] :: Authorizer -> Map ByteString User
[_authAnon] :: Authorizer -> Bool
authUsers :: Lens' Authorizer (Map ByteString User)
authAnon :: Lens' Authorizer Bool
data Retained
Retained :: UTCTime -> Maybe UTCTime -> PublishRequest -> Retained
[_retainTS] :: Retained -> UTCTime
[_retainExp] :: Retained -> Maybe UTCTime
[_retainMsg] :: Retained -> PublishRequest
retainTS :: Lens' Retained UTCTime
retainMsg :: Lens' Retained PublishRequest
retainExp :: Lens' Retained (Maybe UTCTime)
instance GHC.Show.Show MQTTD.Types.Retained
instance GHC.Show.Show MQTTD.Types.Authorizer
instance GHC.Show.Show MQTTD.Types.ConnectedClient
instance GHC.Show.Show MQTTD.Types.MQTTException
instance GHC.Exception.Type.Exception MQTTD.Types.MQTTException

module MQTTD.Util
textToBL :: Text -> ByteString
blToText :: ByteString -> Text
tshow :: Show a => a -> Text
justM :: Monad m => (a -> m ()) -> Maybe a -> m ()

module MQTTD.DB
class Monad m => HasDBConnection m
dbConn :: HasDBConnection m => m Connection
dbQueue :: HasDBConnection m => m (TBQueue DBOperation)
data DBOperation
DeleteSession :: SessionID -> DBOperation
StoreSession :: Session -> DBOperation
DeleteRetained :: BLTopic -> DBOperation
StoreRetained :: Retained -> DBOperation
initQueries :: [(Int, Query)]
initTables :: Connection -> IO ()
initDB :: Connection -> IO ()
runOperations :: (HasDBConnection m, MonadIO m, MonadLogger m) => m ()
writeDBQueue :: (HasDBConnection m, MonadIO m) => DBOperation -> m ()
deleteSessionL :: MonadIO m => Connection -> SessionID -> m ()
deleteSession :: (HasDBConnection m, MonadIO m) => SessionID -> m ()
deleteRetained :: (HasDBConnection m, MonadIO m) => BLTopic -> m ()
deleteRetainedL :: MonadIO m => Connection -> BLTopic -> m ()
storeSession :: (HasDBConnection m, MonadIO m) => Session -> m ()
storeSessionL :: MonadIO m => Connection -> Session -> m ()
data StoredSub
StoredSub :: SessionID -> Filter -> SubOptions -> StoredSub
[_ss_sessID] :: StoredSub -> SessionID
[_ss_topic] :: StoredSub -> Filter
[_ss_opts] :: StoredSub -> SubOptions
data StoredSession
StoredSession :: SessionID -> Int -> Maybe BLTopic -> Maybe Bool -> Maybe QoS -> Maybe ByteString -> [Property] -> StoredSession
[_sts_sessionID] :: StoredSession -> SessionID
[_sts_expiry] :: StoredSession -> Int
[_sts_willTopic] :: StoredSession -> Maybe BLTopic
[_sts_willRetain] :: StoredSession -> Maybe Bool
[_sts_willQoS] :: StoredSession -> Maybe QoS
[_sts_willBody] :: StoredSession -> Maybe ByteString
[_sts_willProps] :: StoredSession -> [Property]
loadSessions :: (HasDBConnection m, MonadIO m) => m [Session]
storeRetained :: (HasDBConnection m, MonadIO m) => Retained -> m ()
storeRetainedL :: MonadIO m => Connection -> Retained -> m ()
loadRetained :: (HasDBConnection m, MonadIO m) => m [Retained]
instance Database.SQLite.Simple.FromRow.FromRow MQTTD.DB.StoredSession
instance Database.SQLite.Simple.FromRow.FromRow MQTTD.DB.StoredSub
instance Database.SQLite.Simple.ToRow.ToRow MQTTD.Types.Session
instance Database.SQLite.Simple.ToRow.ToRow MQTTD.Types.Retained
instance Database.SQLite.Simple.FromRow.FromRow MQTTD.Types.Retained

module Scheduler
type TimedQueue a = Map UTCTime [a]
add :: Ord a => UTCTime -> a -> TimedQueue a -> TimedQueue a
ready :: UTCTime -> TimedQueue a -> ([a], TimedQueue a)
next :: TimedQueue a -> Maybe UTCTime
newtype QueueRunner a
QueueRunner :: TVar (TimedQueue a) -> QueueRunner a
[_tq] :: QueueRunner a -> TVar (TimedQueue a)
newRunner :: MonadIO m => m (QueueRunner a)
enqueue :: (Ord a, MonadIO m) => UTCTime -> a -> QueueRunner a -> m ()

-- | Run forever.
run :: (MonadLogger m, MonadIO m) => (a -> m ()) -> QueueRunner a -> m ()

-- | Block until an item might be ready and then run (and remove) all ready
--   items. This will sometimes run 0 items. It shouldn't ever run any
--   items that are scheduled for the future, and it shouldn't forget any
--   items that are ready.
runOnce :: (MonadLogger m, MonadIO m) => (a -> m ()) -> QueueRunner a -> m ()
diffTimeToMicros :: NominalDiffTime -> Int

module MQTTD.Retention
data Retainer
Retainer :: TVar (Map BLTopic Retained) -> QueueRunner BLTopic -> Retainer
[_store] :: Retainer -> TVar (Map BLTopic Retained)
[_qrunner] :: Retainer -> QueueRunner BLTopic
newRetainer :: MonadIO m => m Retainer
cleanRetainer :: (MonadLogger m, HasDBConnection m, MonadUnliftIO m) => Retainer -> m ()
retain :: (MonadLogger m, HasDBConnection m, MonadIO m) => PublishRequest -> Retainer -> m ()
restoreRetained :: (MonadIO m, HasDBConnection m) => Retainer -> m ()
matchRetained :: MonadIO m => Retainer -> Filter -> m [PublishRequest]
absExp :: Integral a => UTCTime -> a -> UTCTime
relExp :: Integral p => UTCTime -> UTCTime -> p

module MQTTD
data Env
Env :: TVar (Map SessionID Session) -> TVar Word16 -> TVar ClientID -> TVar (SubTree (Map SessionID SubOptions)) -> QueueRunner SessionID -> Retainer -> Authorizer -> Connection -> TBQueue DBOperation -> Env
[sessions] :: Env -> TVar (Map SessionID Session)
[lastPktID] :: Env -> TVar Word16
[clientIDGen] :: Env -> TVar ClientID
[allSubs] :: Env -> TVar (SubTree (Map SessionID SubOptions))
[queueRunner] :: Env -> QueueRunner SessionID
[retainer] :: Env -> Retainer
[authorizer] :: Env -> Authorizer
[dbConnection] :: Env -> Connection
[dbQ] :: Env -> TBQueue DBOperation
newtype MQTTD m a
MQTTD :: ReaderT Env m a -> MQTTD m a
[runMQTTD] :: MQTTD m a -> ReaderT Env m a
runIO :: (MonadIO m, MonadLogger m) => Env -> MQTTD m a -> m a
newEnv :: MonadIO m => Authorizer -> Connection -> m Env
modifyAuthorizer :: Monad m => (Authorizer -> Authorizer) -> MQTTD m a -> MQTTD m a
seconds :: Num p => p -> p
nextID :: MonadIO m => MQTTD m Int
type PublishConstraint m = (MonadLogger m, MonadFail m, MonadMask m, MonadUnliftIO m, MonadIO m)
sessionCleanup :: PublishConstraint m => MQTTD m ()
retainerCleanup :: (MonadUnliftIO m, MonadLogger m) => MQTTD m ()
resolveAliasIn :: MonadIO m => Session -> PublishRequest -> m PublishRequest
findSubs :: MonadIO m => Topic -> MQTTD m [(Session, SubOptions)]
restoreSessions :: PublishConstraint m => MQTTD m ()
restoreRetained :: MonadIO m => MQTTD m ()
subscribe :: PublishConstraint m => Session -> SubscribeRequest -> MQTTD m [Either SubErr QoS]
removeSubs :: TVar (SubTree (Map SessionID SubOptions)) -> SessionID -> [Filter] -> STM ()
unsubscribe :: MonadIO m => Session -> [BLFilter] -> MQTTD m [UnsubStatus]
modifySession :: MonadIO m => SessionID -> (Session -> Maybe Session) -> MQTTD m ()
registerClient :: MonadIO m => ConnectRequest -> ClientID -> ThreadId -> MQTTD m (Session, SessionReuse)
expireSession :: PublishConstraint m => SessionID -> MQTTD m ()
unregisterClient :: (MonadLogger m, MonadMask m, MonadFail m, MonadUnliftIO m, MonadIO m) => SessionID -> ClientID -> MQTTD m ()
sendPacket :: PktQueue -> MQTTPkt -> STM Bool
sendPacket_ :: PktQueue -> MQTTPkt -> STM ()
sendPacketIO :: MonadIO m => PktQueue -> MQTTPkt -> m Bool
sendPacketIO_ :: MonadIO m => PktQueue -> MQTTPkt -> m ()
modifyTVarRet :: TVar a -> (a -> a) -> STM a
nextPktID :: TVar Word16 -> STM Word16
broadcast :: PublishConstraint m => Maybe SessionID -> PublishRequest -> MQTTD m ()
publish :: PublishConstraint m => Session -> PublishRequest -> MQTTD m ()
aliasOut :: ConnectedClient -> PublishRequest -> STM PublishRequest
authTopic :: Topic -> [ACL] -> Either String ()
dispatch :: PublishConstraint m => Session -> MQTTPkt -> MQTTD m ()
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (MQTTD.MQTTD m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader MQTTD.Env (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (MQTTD.MQTTD m)
instance Control.Monad.Logger.MonadLogger m => Control.Monad.Logger.MonadLogger (MQTTD.MQTTD m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (MQTTD.MQTTD m)
instance GHC.Base.Monad m => GHC.Base.Monad (MQTTD.MQTTD m)
instance GHC.Base.Functor m => GHC.Base.Functor (MQTTD.MQTTD m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (MQTTD.MQTTD m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => Control.Monad.IO.Unlift.MonadUnliftIO (MQTTD.MQTTD m)
instance (GHC.Base.Monad m, Control.Monad.Reader.Class.MonadReader MQTTD.Env m) => MQTTD.DB.HasDBConnection m

module MQTTD.Conduit
type MQTTConduit m = (ConduitT () ByteString (MQTTD m) (), ConduitT ByteString Void (MQTTD m) ())
authorize :: (MonadFail m, Monad m) => ConnectRequest -> MQTTD m (Either String ())
runMQTTDConduit :: forall m. PublishConstraint m => MQTTConduit m -> MQTTD m ()
webSocketsApp :: PublishConstraint m => PendingConnection -> MQTTD m ()
tcpApp :: PublishConstraint m => AppData -> MQTTD m ()
