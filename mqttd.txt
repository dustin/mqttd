-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/dustin/mqttd#readme</a>
@package mqttd
@version 0.1.0.0

module MQTTD.Config
data Config
Config :: Bool -> Map ByteString User -> [Listener] -> ListenerOptions -> PersistenceConfig -> Config
[_confDebug] :: Config -> Bool
[_confUsers] :: Config -> Map ByteString User
[_confListeners] :: Config -> [Listener]
[_confDefaults] :: Config -> ListenerOptions
[_confPersist] :: Config -> PersistenceConfig
data User
User :: ByteString -> ByteString -> [ACL] -> User
data ACL
Allow :: Filter -> ACL
Deny :: Filter -> ACL
newtype PersistenceConfig
PersistenceConfig :: FilePath -> PersistenceConfig
[_persistenceDBPath] :: PersistenceConfig -> FilePath
data Listener
MQTTListener :: HostPreference -> PortNumber -> ListenerOptions -> Listener
MQTTSListener :: HostPreference -> PortNumber -> FilePath -> FilePath -> ListenerOptions -> Listener
WSListener :: ListenAddress -> PortNumber -> ListenerOptions -> Listener
data ListenerOptions
ListenerOptions :: Maybe Bool -> ListenerOptions
[_optAllowAnonymous] :: ListenerOptions -> Maybe Bool
listenerOpts :: Lens' Listener ListenerOptions
parseConfFile :: String -> IO Config
instance GHC.Show.Show MQTTD.Config.Section
instance GHC.Classes.Eq MQTTD.Config.Config
instance GHC.Show.Show MQTTD.Config.Config
instance GHC.Classes.Eq MQTTD.Config.PersistenceConfig
instance GHC.Show.Show MQTTD.Config.PersistenceConfig
instance GHC.Classes.Eq MQTTD.Config.Listener
instance GHC.Show.Show MQTTD.Config.Listener
instance GHC.Show.Show MQTTD.Config.ListenerOptions
instance GHC.Classes.Eq MQTTD.Config.ListenerOptions
instance GHC.Classes.Eq MQTTD.Config.User
instance GHC.Show.Show MQTTD.Config.User
instance GHC.Classes.Eq MQTTD.Config.ACL
instance GHC.Show.Show MQTTD.Config.ACL
instance GHC.Base.Semigroup MQTTD.Config.ListenerOptions
instance GHC.Base.Monoid MQTTD.Config.ListenerOptions

module MQTTD.Stats
data StatKey
StatMsgSent :: StatKey
StatMsgRcvd :: StatKey
StatBytesSent :: StatKey
StatBytesRcvd :: StatKey
StatStoreTransactions :: StatKey
StatStoreOperations :: StatKey
StatsActionQueued :: StatKey
StatsActionExecuted :: StatKey
statKeyName :: StatKey -> ByteString
type Increment = (StatKey, Int)
data StatStore
StatStore :: TBQueue Increment -> TVar (Map StatKey Int) -> StatStore
[_stats_queue] :: StatStore -> TBQueue Increment
[_stats_map] :: StatStore -> TVar (Map StatKey Int)
class HasStats m
statStore :: HasStats m => m StatStore
newStatStore :: MonadIO m => m StatStore
applyStats :: MonadIO m => StatStore -> m ()
incrementStatSTM :: StatKey -> Int -> StatStore -> STM ()
incrementStat :: (MonadIO m, HasStats m) => StatKey -> Int -> m ()
retrieveStats :: (MonadIO m, HasStats m) => m (Map StatKey Int)
instance GHC.Enum.Enum MQTTD.Stats.StatKey
instance GHC.Classes.Ord MQTTD.Stats.StatKey
instance GHC.Show.Show MQTTD.Stats.StatKey
instance GHC.Classes.Eq MQTTD.Stats.StatKey

module MQTTD.SubTree

-- | MQTT Topic Subscription tree.
data SubTree a

-- | An empty SubTree.
--   
--   This exists in addition to <a>mempty</a> so one can create a SubTree
--   for a values that are not monoidal.
empty :: SubTree a

-- | Modify a subscription for the given filter.
--   
--   This will create structure along the path and will not clean up any
--   unused structure.
modify :: Filter -> (Maybe a -> Maybe a) -> SubTree a -> SubTree a

-- | Add a value at the given filter path.
add :: Monoid a => Filter -> a -> SubTree a -> SubTree a

-- | Add a value at the given filter path with the given collision
--   function.
addWith :: Monoid a => Filter -> (a -> a -> a) -> a -> SubTree a -> SubTree a

-- | Find subscribers of a given topic.
find :: Monoid a => Topic -> SubTree a -> a

-- | Find all matching subscribers
findMap :: Monoid m => Topic -> (a -> m) -> SubTree a -> m

-- | flatten a SubTree to a list of (topic,a) pairs.
flatten :: SubTree a -> [(Filter, a)]

-- | Construct a SubTree from a list of filters and subscribers (assuming
--   monoidal values).
fromList :: Monoid a => [(Filter, a)] -> SubTree a
instance Data.Traversable.Traversable MQTTD.SubTree.SubTree
instance Data.Foldable.Foldable MQTTD.SubTree.SubTree
instance GHC.Base.Functor MQTTD.SubTree.SubTree
instance GHC.Classes.Eq a => GHC.Classes.Eq (MQTTD.SubTree.SubTree a)
instance GHC.Show.Show a => GHC.Show.Show (MQTTD.SubTree.SubTree a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (MQTTD.SubTree.SubTree a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (MQTTD.SubTree.SubTree a)

module MQTTD.Types
data MQTTException
MQTTPingTimeout :: MQTTException
MQTTDuplicate :: SessionID -> MQTTException
type PktQueue = TBQueue MQTTPkt
type ClientID = Int
type SessionID = ByteString
type BLTopic = ByteString
type BLFilter = ByteString
type SubscriberName = Text
defaultQueueSize :: Num a => a
data ConnectedClient
ConnectedClient :: ConnectRequest -> ThreadId -> ClientID -> TVar (Map Word16 ByteString) -> TVar (Map ByteString Word16) -> TVar Word16 -> ConnectedClient
[_clientConnReq] :: ConnectedClient -> ConnectRequest
[_clientThread] :: ConnectedClient -> ThreadId
[_clientID] :: ConnectedClient -> ClientID
[_clientAliasIn] :: ConnectedClient -> TVar (Map Word16 ByteString)
[_clientAliasOut] :: ConnectedClient -> TVar (Map ByteString Word16)
[_clientALeft] :: ConnectedClient -> TVar Word16
clientThread :: Lens' ConnectedClient ThreadId
clientID :: Lens' ConnectedClient ClientID
clientConnReq :: Lens' ConnectedClient ConnectRequest
clientAliasOut :: Lens' ConnectedClient (TVar (Map ByteString Word16))
clientAliasIn :: Lens' ConnectedClient (TVar (Map Word16 ByteString))
clientALeft :: Lens' ConnectedClient (TVar Word16)
data Session
Session :: SessionID -> [ACL] -> Maybe ConnectedClient -> PktQueue -> TVar Word16 -> TBQueue PublishRequest -> TVar (Map PktID PublishRequest) -> TVar (Map Filter SubOptions) -> Maybe UTCTime -> Maybe LastWill -> Session
[_sessionID] :: Session -> SessionID
[_sessionACL] :: Session -> [ACL]
[_sessionClient] :: Session -> Maybe ConnectedClient
[_sessionChan] :: Session -> PktQueue
[_sessionFlight] :: Session -> TVar Word16
[_sessionBacklog] :: Session -> TBQueue PublishRequest
[_sessionQP] :: Session -> TVar (Map PktID PublishRequest)
[_sessionSubs] :: Session -> TVar (Map Filter SubOptions)
[_sessionExpires] :: Session -> Maybe UTCTime
[_sessionWill] :: Session -> Maybe LastWill
sessionWill :: Lens' Session (Maybe LastWill)
sessionSubs :: Lens' Session (TVar (Map Filter SubOptions))
sessionQP :: Lens' Session (TVar (Map PktID PublishRequest))
sessionID :: Lens' Session SessionID
sessionFlight :: Lens' Session (TVar Word16)
sessionExpires :: Lens' Session (Maybe UTCTime)
sessionClient :: Lens' Session (Maybe ConnectedClient)
sessionChan :: Lens' Session PktQueue
sessionBacklog :: Lens' Session (TBQueue PublishRequest)
sessionACL :: Lens' Session [ACL]
defaultSessionExp :: NominalDiffTime
data Authorizer
Authorizer :: Map ByteString User -> Bool -> Authorizer
[_authUsers] :: Authorizer -> Map ByteString User
[_authAnon] :: Authorizer -> Bool
authUsers :: Lens' Authorizer (Map ByteString User)
authAnon :: Lens' Authorizer Bool
data Retained
Retained :: UTCTime -> Maybe UTCTime -> PublishRequest -> Retained
[_retainTS] :: Retained -> UTCTime
[_retainExp] :: Retained -> Maybe UTCTime
[_retainMsg] :: Retained -> PublishRequest
retainTS :: Lens' Retained UTCTime
retainMsg :: Lens' Retained PublishRequest
retainExp :: Lens' Retained (Maybe UTCTime)
type PublishConstraint m = (MonadLogger m, MonadFail m, MonadMask m, MonadUnliftIO m, MonadIO m)
data TopicType
Normal :: Topic -> TopicType
SharedSubscription :: SubscriberName -> Filter -> TopicType
InvalidTopic :: TopicType
classifyTopic :: Text -> TopicType
partitionShared :: [(Filter, o)] -> ([(SubscriberName, Filter, o)], [(Filter, o)])
instance GHC.Show.Show MQTTD.Types.TopicType
instance GHC.Classes.Eq MQTTD.Types.TopicType
instance GHC.Show.Show MQTTD.Types.Retained
instance GHC.Show.Show MQTTD.Types.Authorizer
instance GHC.Show.Show MQTTD.Types.ConnectedClient
instance GHC.Show.Show MQTTD.Types.MQTTException
instance GHC.Exception.Type.Exception MQTTD.Types.MQTTException

module MQTTD.Util
textToBL :: Text -> ByteString
blToText :: ByteString -> Text
tshow :: Show a => a -> Text
justM :: Monad m => (a -> m ()) -> Maybe a -> m ()

module MQTTD.GCStats
hasGCStats :: MonadIO m => m Bool
pubGCStats :: forall m. PublishConstraint m => (ByteString -> ByteString -> m ()) -> m ()

module MQTTD.DB
class Monad m => HasDBConnection m
dbConn :: HasDBConnection m => m Connection
dbQueue :: HasDBConnection m => m (TBQueue DBOperation)
data DBOperation
DeleteSession :: SessionID -> DBOperation
StoreSession :: Session -> DBOperation
DeleteRetained :: BLTopic -> DBOperation
StoreRetained :: Retained -> DBOperation
initQueries :: [(Int, Query)]
initTables :: Connection -> IO ()
initDB :: Connection -> IO ()
runOperations :: (HasDBConnection m, HasStats m, MonadIO m, MonadLogger m) => m ()
writeDBQueue :: (HasDBConnection m, MonadIO m) => DBOperation -> m ()
deleteSessionL :: MonadIO m => Connection -> SessionID -> m ()
deleteSession :: (HasDBConnection m, MonadIO m) => SessionID -> m ()
deleteRetained :: (HasDBConnection m, MonadIO m) => BLTopic -> m ()
deleteRetainedL :: MonadIO m => Connection -> BLTopic -> m ()
storeSession :: (HasDBConnection m, MonadIO m) => Session -> m ()
storeSessionL :: MonadIO m => Connection -> Session -> m ()
data StoredSub
StoredSub :: SessionID -> Filter -> SubOptions -> StoredSub
[_ss_sessID] :: StoredSub -> SessionID
[_ss_topic] :: StoredSub -> Filter
[_ss_opts] :: StoredSub -> SubOptions
data StoredSession
StoredSession :: SessionID -> Int -> Maybe BLTopic -> Maybe Bool -> Maybe QoS -> Maybe ByteString -> [Property] -> StoredSession
[_sts_sessionID] :: StoredSession -> SessionID
[_sts_expiry] :: StoredSession -> Int
[_sts_willTopic] :: StoredSession -> Maybe BLTopic
[_sts_willRetain] :: StoredSession -> Maybe Bool
[_sts_willQoS] :: StoredSession -> Maybe QoS
[_sts_willBody] :: StoredSession -> Maybe ByteString
[_sts_willProps] :: StoredSession -> [Property]
loadSessions :: (HasDBConnection m, MonadIO m) => m [Session]
storeRetained :: (HasDBConnection m, MonadIO m) => Retained -> m ()
storeRetainedL :: MonadIO m => Connection -> Retained -> m ()
loadRetained :: (HasDBConnection m, MonadIO m) => m [Retained]
instance Database.SQLite.Simple.FromRow.FromRow MQTTD.DB.StoredSession
instance Database.SQLite.Simple.FromRow.FromRow MQTTD.DB.StoredSub
instance Database.SQLite.Simple.ToRow.ToRow MQTTD.Types.Session
instance Database.SQLite.Simple.ToRow.ToRow MQTTD.Types.Retained
instance Database.SQLite.Simple.FromRow.FromRow MQTTD.Types.Retained

module Scheduler
type TimedQueue a = Map UTCTime [a]
add :: Ord a => UTCTime -> a -> TimedQueue a -> TimedQueue a
ready :: UTCTime -> TimedQueue a -> ([a], TimedQueue a)
next :: TimedQueue a -> Maybe UTCTime
newtype QueueRunner a
QueueRunner :: TVar (TimedQueue a) -> QueueRunner a
[_tq] :: QueueRunner a -> TVar (TimedQueue a)
newRunner :: MonadIO m => m (QueueRunner a)
enqueue :: (HasStats m, Ord a, MonadIO m) => UTCTime -> a -> QueueRunner a -> m ()

-- | Run forever.
run :: (HasStats m, MonadLogger m, MonadIO m) => (a -> m ()) -> QueueRunner a -> m ()

-- | Block until an item might be ready and then run (and remove) all ready
--   items. This will sometimes run 0 items. It shouldn't ever run any
--   items that are scheduled for the future, and it shouldn't forget any
--   items that are ready.
runOnce :: (HasStats m, MonadLogger m, MonadIO m) => (a -> m ()) -> QueueRunner a -> m ()
diffTimeToMicros :: NominalDiffTime -> Int

module MQTTD.Retention
data Retainer
Retainer :: TVar (Map BLTopic Retained) -> QueueRunner BLTopic -> Retainer
[_store] :: Retainer -> TVar (Map BLTopic Retained)
[_qrunner] :: Retainer -> QueueRunner BLTopic
newRetainer :: MonadIO m => m Retainer
cleanRetainer :: (HasStats m, MonadLogger m, HasDBConnection m, MonadUnliftIO m) => Retainer -> m ()
isSys :: BLTopic -> Bool
retain :: (HasStats m, MonadLogger m, HasDBConnection m, MonadIO m) => PublishRequest -> Retainer -> m ()
restoreRetained :: (HasStats m, MonadIO m, HasDBConnection m) => Retainer -> m ()
matchRetained :: MonadIO m => Retainer -> Filter -> m [PublishRequest]
absExp :: Integral a => UTCTime -> a -> UTCTime
relExp :: Integral p => UTCTime -> UTCTime -> p

module MQTTD
data Env
Env :: TVar (Map SessionID Session) -> TVar Word16 -> TVar ClientID -> TVar (SubTree (Map SessionID SubOptions)) -> TVar (SubTree (Map SubscriberName [(SessionID, SubOptions)])) -> QueueRunner SessionID -> Retainer -> Authorizer -> Connection -> TBQueue DBOperation -> StatStore -> Env
[sessions] :: Env -> TVar (Map SessionID Session)
[lastPktID] :: Env -> TVar Word16
[clientIDGen] :: Env -> TVar ClientID
[allSubs] :: Env -> TVar (SubTree (Map SessionID SubOptions))
[sharedSubs] :: Env -> TVar (SubTree (Map SubscriberName [(SessionID, SubOptions)]))
[queueRunner] :: Env -> QueueRunner SessionID
[retainer] :: Env -> Retainer
[authorizer] :: Env -> Authorizer
[dbConnection] :: Env -> Connection
[dbQ] :: Env -> TBQueue DBOperation
[stats] :: Env -> StatStore
newtype MQTTD m a
MQTTD :: ReaderT Env m a -> MQTTD m a
[runMQTTD] :: MQTTD m a -> ReaderT Env m a
runIO :: (MonadIO m, MonadLogger m) => Env -> MQTTD m a -> m a
newEnv :: MonadIO m => Authorizer -> Connection -> m Env
modifyAuthorizer :: Monad m => (Authorizer -> Authorizer) -> MQTTD m a -> MQTTD m a
seconds :: Num p => p -> p
nextID :: MonadIO m => MQTTD m Int
sessionCleanup :: PublishConstraint m => MQTTD m ()
retainerCleanup :: (MonadUnliftIO m, MonadLogger m) => MQTTD m ()
isClientConnected :: SessionID -> TVar (Map SessionID Session) -> STM Bool
publishStats :: PublishConstraint m => MQTTD m ()
resolveAliasIn :: MonadIO m => Session -> PublishRequest -> m PublishRequest
findSubs :: MonadIO m => Topic -> MQTTD m [(Session, SubOptions)]
restoreSessions :: PublishConstraint m => MQTTD m ()
restoreRetained :: MonadIO m => MQTTD m ()
subscribe :: PublishConstraint m => Session -> SubscribeRequest -> MQTTD m ()
removeSubs :: TVar (SubTree (Map SubscriberName [(SessionID, SubOptions)])) -> TVar (SubTree (Map SessionID SubOptions)) -> SessionID -> [Filter] -> STM ()
unsubscribe :: MonadIO m => Session -> [BLFilter] -> MQTTD m [UnsubStatus]
modifySession :: MonadIO m => SessionID -> (Session -> Maybe Session) -> MQTTD m ()
registerClient :: (MonadFail m, MonadIO m) => ConnectRequest -> ClientID -> ThreadId -> MQTTD m (Session, SessionReuse)
expireSession :: PublishConstraint m => SessionID -> MQTTD m ()
unregisterClient :: PublishConstraint m => SessionID -> ClientID -> MQTTD m ()
tryWriteQ :: TBQueue a -> a -> STM Bool
sendPacket :: PktQueue -> MQTTPkt -> STM Bool
sendPacket_ :: PktQueue -> MQTTPkt -> STM ()
sendPacketIO :: MonadIO m => PktQueue -> MQTTPkt -> m Bool
sendPacketIO_ :: MonadIO m => PktQueue -> MQTTPkt -> m ()
modifyTVarRet :: TVar a -> (a -> a) -> STM a
nextPktID :: (Enum a, Bounded a, Eq a, Num a) => TVar a -> STM a
broadcast :: PublishConstraint m => Maybe SessionID -> PublishRequest -> MQTTD m ()
publish :: PublishConstraint m => Session -> PublishRequest -> MQTTD m ()
deliver :: StatStore -> Session -> PublishRequest -> STM ()
aliasOut :: ConnectedClient -> PublishRequest -> STM PublishRequest
topicTypeTopic :: TopicType -> Topic
authTopic :: TopicType -> [ACL] -> Either String ()
releasePubSlot :: StatStore -> Session -> STM ()
dispatch :: PublishConstraint m => Session -> MQTTPkt -> MQTTD m ()
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (MQTTD.MQTTD m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader MQTTD.Env (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (MQTTD.MQTTD m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (MQTTD.MQTTD m)
instance Control.Monad.Logger.MonadLogger m => Control.Monad.Logger.MonadLogger (MQTTD.MQTTD m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (MQTTD.MQTTD m)
instance GHC.Base.Monad m => GHC.Base.Monad (MQTTD.MQTTD m)
instance GHC.Base.Functor m => GHC.Base.Functor (MQTTD.MQTTD m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (MQTTD.MQTTD m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => Control.Monad.IO.Unlift.MonadUnliftIO (MQTTD.MQTTD m)
instance GHC.Base.Monad m => MQTTD.Stats.HasStats (MQTTD.MQTTD m)
instance (GHC.Base.Monad m, Control.Monad.Reader.Class.MonadReader MQTTD.Env m) => MQTTD.DB.HasDBConnection m

module MQTTD.Conduit
type MQTTConduit m = (ConduitT () ByteString (MQTTD m) (), ConduitT ByteString Void (MQTTD m) (), Text)
authorize :: (MonadFail m, Monad m) => ConnectRequest -> MQTTD m (Either String ())
runMQTTDConduit :: forall m. PublishConstraint m => MQTTConduit m -> MQTTD m ()
webSocketsApp :: PublishConstraint m => PendingConnection -> MQTTD m ()
tcpApp :: PublishConstraint m => AppData -> MQTTD m ()

module MQTTD.Main
runListener :: (MonadUnliftIO m, MonadLogger m, MonadFail m, MonadMask m) => Listener -> MQTTD m (Async ())
pause :: MonadIO m => m ()
runServerLogging :: (MonadFail m, MonadMask m, MonadUnliftIO m, MonadIO m, MonadLogger m) => Config -> m [Async ()]
runServer :: Config -> IO [Async ()]
